import React, { Suspense } from 'react';
import { Implementation, Preview, Header, Display, TechnologyUsed, Wrapper, Skeleton, PARTITION } from "@/components/mdx/MDXServerImports"
import { CodeBlock } from "@/components/mdx/MDXClientImports"


{/*
// ------------------------------------------------------------------------------------
//	The text below is generated from src/content/docs/primitives/toasts/Toast_Main.mdx
// ------------------------------------------------------------------------------------
*/}


<Wrapper>

# Toast Architecture
### The Toast component is a versatile notification system designed to display toasts in both stacked and unstacked layouts. With support for multiple states such as success, error, warning, and info, it offers a range of customizable options including direction, visibility duration, and close type. Utilizing the useToast hook, this component allows for easy control and integration within any part of your application, ensuring a flexible and dynamic user experience. It's totally developed without any external dependencies, making it a lightweight and efficient choice for your notification needs.





export const ToastImplementation_primitives_toasts_toast_main = React.lazy(() =>
	import('@/packages/primitives/toasts/Toasts_Main')
		.then((mod) => ({
			default: mod.ToastImplementation
	}))
);


<Header />
<Preview> 


<Suspense fallback={<Skeleton className="h-60 rounded-lg" />}>
<Display>
<ToastImplementation_primitives_toasts_toast_main />
</Display>
</Suspense>

</Preview>

<Implementation>


<TechnologyUsed technologies={[ "tailwind-css" , "twMerge" ]}/>

<CodeBlock>
 
```tsx|Toast_Context
"use client";
import { createContext, useContext, useEffect, useRef, useState } from "react";

export type ToastProps = {
  toastId: string;
  state: "success" | "error" | "warning" | "info";
  children: React.ReactNode;
  visibility: boolean;
  visibilityDuration?: number;
  creationTime: number;
  closeType: "timeout" | "manual";
  duration: number;
};

export type ToastProviderProps = {
  toasts: ToastProps[];
  addToast: (value: ToastProps) => void;
  removeToast: (id: string) => void;
  calculateHierarchy: (toastId: string) => number | null;
  getToast: (id: string) => ToastProps | null;
};

type ContextWrapperProps = {
  children: React.ReactNode;
};

export const ToastContext = createContext<ToastProviderProps>({
  toasts: [],
  addToast: () => {},
  removeToast: () => {},
  calculateHierarchy: () => {
    return null;
  },
  getToast: () => {
    return null;
  },
});

const ToastProvider: React.FC<ContextWrapperProps> = (props) => {
  const [toasts, setToasts] = useState<ToastProps[]>([]);

  const addToast = (value: ToastProps) => {
    setToasts([...toasts, value]);
  };
  const removeToast = (id: string) => {
    const newtoast = toasts.map((toast) => {
      if (toast.toastId === id) {
        return {
          ...toast,
          visibility: false,
        };
      } else {
        return toast;
      }
    });
    setToasts(newtoast);
  };

  const calculateHierarchy = (toastId: string) => {
    var count: number = -1;
    var flag = false;
    var selfvisible = false;

    toasts.forEach((toast) => {
      if (flag === false) {
        if (toast.visibility === true) {
          count++;
        }
      }
      if (toast.toastId === toastId) {
        if (toast.visibility === true) {
          flag = true;
        } else {
          selfvisible = true;
        }
      }
    });

    if (selfvisible) {
      return null;
    } else {
      if (count >= 0) {
        return count;
      } else {
        return null;
      }
    }
  };

  const getToast = (toastId: string) => {
    const toast = toasts.find((toast) => toast.toastId === toastId);
    if (toast) {
      return toast;
    } else return null;
  };

  const value: ToastProviderProps = {
    toasts,
    addToast,
    removeToast,
    calculateHierarchy,
    getToast,
  };

  // Clear the toasts when all are closed. To avoid memory issues
  useEffect(() => {
    function checkAllClosed() {
      var flag = true;
      for (const toast of toasts) {
        if (toast.visibility) {
          flag = false;
          break;
        }
      }
      return flag;
    }
    if (toasts.length === 0) return;
    const check = checkAllClosed();
    if (check) setToasts([]);
  }, [toasts]);

  // -----------------------------------------------------
  // TIMEOUT HANDLER
  // -----------------------------------------------------

  const timeoutsRef = useRef<{ [key: string]: ReturnType<typeof setTimeout> }>(
    {}
  );

  useEffect(() => {
    // Clear existing timeouts
    Object.values(timeoutsRef.current).forEach(clearTimeout);

    // Set new timeouts
    const newTimeouts: { [key: string]: ReturnType<typeof setTimeout> } = {};
    const currentTime = Date.now();

    toasts.forEach((toast) => {
      if (
        toast.visibility &&
        !timeoutsRef.current[toast.toastId] &&
        toast.closeType === "timeout"
      ) {
        const timeElapsed = currentTime - toast.creationTime;
        const remainingTime = toast.duration - timeElapsed;
        if (remainingTime > 0) {
          newTimeouts[toast.toastId] = setTimeout(
            () => removeToast(toast.toastId),
            remainingTime
          );
        } else {
          // If time has already elapsed, remove immediately
          removeToast(toast.toastId);
        }
      }
    });

    // Update timeoutsRef
    timeoutsRef.current = newTimeouts;

    return () => {
      // Clear timeouts on component unmount
      Object.values(timeoutsRef.current).forEach(clearTimeout);
    };
  }, [toasts, removeToast]);

  return (
    <ToastContext.Provider value={value}>
      {props.children}
    </ToastContext.Provider>
  );
};

export const useToast = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error("useToast Hook must be used within the Toast Provider");
  }
  return context;
};

export default ToastProvider;
```
```jsx|Toast_Context
"use client";
import { createContext, useContext, useEffect, useRef, useState } from "react";

export const ToastContext = createContext({
  toasts: [],
  addToast: () => {},
  removeToast: () => {},
  calculateHierarchy: () => {
    return null;
  },
  getToast: () => {
    return null;
  },
});

const ToastProvider = (props) => {
  const [toasts, setToasts] = useState([]);

  const addToast = (value) => {
    setToasts([...toasts, value]);
  };
  const removeToast = (id) => {
    const newtoast = toasts.map((toast) => {
      if (toast.toastId === id) {
        return {
          ...toast,
          visibility: false,
        };
      } else {
        return toast;
      }
    });
    setToasts(newtoast);
  };

  const calculateHierarchy = (toastId) => {
    var count: number = -1;
    var flag = false;
    var selfvisible = false;

    toasts.forEach((toast) => {
      if (flag === false) {
        if (toast.visibility === true) {
          count++;
        }
      }
      if (toast.toastId === toastId) {
        if (toast.visibility === true) {
          flag = true;
        } else {
          selfvisible = true;
        }
      }
    });

    if (selfvisible) {
      return null;
    } else {
      if (count >= 0) {
        return count;
      } else {
        return null;
      }
    }
  };

  const getToast = (toastId) => {
    const toast = toasts.find((toast) => toast.toastId === toastId);
    if (toast) {
      return toast;
    } else return null;
  };

  const value = {
    toasts,
    addToast,
    removeToast,
    calculateHierarchy,
    getToast,
  };

  // Clear the toasts when all are closed. To avoid memory issues
  useEffect(() => {
    function checkAllClosed() {
      var flag = true;
      for (const toast of toasts) {
        if (toast.visibility) {
          flag = false;
          break;
        }
      }
      return flag;
    }
    if (toasts.length === 0) return;
    const check = checkAllClosed();
    if (check) setToasts([]);
  }, [toasts]);

  // -----------------------------------------------------
  // TIMEOUT HANDLER
  // -----------------------------------------------------

  const timeoutsRef = useRef({});

  useEffect(() => {
    // Clear existing timeouts
    Object.values(timeoutsRef.current).forEach(clearTimeout);

    // Set new timeouts
    const newTimeouts = {};
    const currentTime = Date.now();

    toasts.forEach((toast) => {
      if (
        toast.visibility &&
        !timeoutsRef.current[toast.toastId] &&
        toast.closeType === "timeout"
      ) {
        const timeElapsed = currentTime - toast.creationTime;
        const remainingTime = toast.duration - timeElapsed;
        if (remainingTime > 0) {
          newTimeouts[toast.toastId] = setTimeout(
            () => removeToast(toast.toastId),
            remainingTime
          );
        } else {
          // If time has already elapsed, remove immediately
          removeToast(toast.toastId);
        }
      }
    });

    // Update timeoutsRef
    timeoutsRef.current = newTimeouts;

    return () => {
      // Clear timeouts on component unmount
      Object.values(timeoutsRef.current).forEach(clearTimeout);
    };
  }, [toasts, removeToast]);

  return (
    <ToastContext.Provider value={value}>
      {props.children}
    </ToastContext.Provider>
  );
};

export const useToast = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error("useToast Hook must be used within the Toast Provider");
  }
  return context;
};

export default ToastProvider;
```

```tsx|Toast_Logic
"use client";
import { ButtonHTMLAttributes, useEffect, useState } from "react";
import { twMerge } from "tailwind-merge";
import { v4 } from "uuid";
import ToastProvider, { ToastProps, useToast } from "./Toasts_Context";

type DirectionProps = "top-left" | "top-right" | "bottom-left" | "bottom-right";

function ToastGroup({
  direction,
  createStack,
}: {
  direction: DirectionProps;
  createStack?: boolean;
}) {
  const { toasts } = useToast();

  return (
    <div
      className={twMerge(
        "absolute flex flex-col gap-4 group/toast transition-all duration-300 ease-linear",
        direction === "top-right" && "top-4 right-4",
        direction === "bottom-right" && "bottom-4 right-4 flex-col-reverse",
        direction === "top-left" && "top-4 left-4",
        direction === "bottom-left" && "bottom-4 left-4 flex-col-reverse"
      )}
    >
      {toasts.map((toast) => (
        <Toast
          key={toast.toastId}
          toastId={toast.toastId}
          createStack={createStack}
          direction={direction}
        />
      ))}
    </div>
  );
}

function Toast({
  toastId,
  createStack,
  direction,
}: {
  toastId: string;
  createStack?: boolean;
  direction: DirectionProps;
}) {
  const gapBetweenCardsInGroup = 0.5;

  const { toasts, getToast, calculateHierarchy } = useToast();
  const toast = getToast(toastId);
  const [hierarchy, setHierarchy] = useState<number | null>(null);

  const [isEntering, setIsEntering] = useState(false);
  const [isExiting, setIsExiting] = useState(false);
  const [isOpen, setIsOpen] = useState(false);

  useEffect(() => {
    const index = calculateHierarchy(toastId);
    setHierarchy(index);

    if (!isOpen && toast?.visibility) {
      setIsEntering(true);
      setIsOpen(true);

      setTimeout(() => {
        setIsEntering(false);
      }, 500);
    } else if (isOpen && !toast?.visibility) {
      setIsExiting(true);

      setTimeout(() => {
        setIsOpen(false);
        setIsExiting(false);
      }, 300);
    }
  }, [toast]); // eslint-disable-line react-hooks/exhaustive-deps

  const directionDependentPositioning: {
    [key: string]: {
      top?: string;
      right?: string;
      bottom?: string;
      left?: string;
    };
  } = {
    "top-right": {
      top: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
      right: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
    },
    "bottom-right": {
      right: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
      bottom: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
    },
    "top-left": {
      top: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
      left: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
    },
    "bottom-left": {
      left: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
      bottom: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
    },
  };

  return (
    <>
      {isOpen && (
        <div
          className={twMerge(
            "overflow-hidden w-max flex flex-col justify-between group-hover/toast:static transition-all duration-300 ease-linear",
            createStack ? "absolute" : "static",
            direction === "top-right" || direction === "bottom-right"
              ? "data-[entering=true]:animate-toastEntryRight data-[exiting=true]:animate-toastExit duration-200"
              : "data-[entering=true]:animate-toastEntryLeft data-[exiting=true]:animate-toastExit duration-200"
          )}
          style={
            createStack
              ? {
                  ...directionDependentPositioning[direction],
                  zIndex: hierarchy !== null ? hierarchy : -1,
                }
              : {}
          }
          data-entering={isEntering}
          data-exiting={isExiting}
          data-open={isOpen}
        >
          <ToastStyling toast={toast} />
        </div>
      )}
    </>
  );
}

// This is the only that you need to change in the code if you want custom styling
const ToastStyling = ({ toast }: { toast: ToastProps | null }) => {
  const { removeToast } = useToast();

  return (
    <>
      {toast && (
        <div
          className={twMerge(
            "min-w-80 min-h-full rounded-md text-textPrimary flex justify-between font-semibold border-2 gap-6 py-2 px-4",
            toast.state === "success" &&
              "bg-success-secondary border-success text-success-foreground ",
            toast.state === "error" &&
              "bg-error-secondary border-error text-error-foreground",
            toast.state === "warning" &&
              "bg-alert-secondary border-alert text-alert-foreground",
            toast.state === "info" &&
              "bg-accent-secondary border-accent text-accent-foreground"
          )}
        >
          {toast.children}
          <button
            onClick={() => removeToast(toast.toastId)}
            className={twMerge(toast.closeType === "timeout" && "hidden")}
          >
            &#10005;
          </button>
        </div>
      )}
    </>
  );
};
```
```jsx|Toast_Logic
"use client";
import { ButtonHTMLAttributes, useEffect, useState } from "react";
import { twMerge } from "tailwind-merge";
import { v4 } from "uuid";
import ToastProvider, { ToastProps, useToast } from "./Toasts_Context";


function ToastGroup({
  direction,
  createStack,
}) {
  const { toasts } = useToast();

  return (
    <div
      className={twMerge(
        "absolute flex flex-col gap-4 group/toast transition-all duration-300 ease-linear",
        direction === "top-right" && "top-4 right-4",
        direction === "bottom-right" && "bottom-4 right-4 flex-col-reverse",
        direction === "top-left" && "top-4 left-4",
        direction === "bottom-left" && "bottom-4 left-4 flex-col-reverse"
      )}
    >
      {toasts.map((toast) => (
        <Toast
          key={toast.toastId}
          toastId={toast.toastId}
          createStack={createStack}
          direction={direction}
        />
      ))}
    </div>
  );
}

function Toast({
  toastId,
  createStack,
  direction,
}) {
  const gapBetweenCardsInGroup = 0.5;

  const { toasts, getToast, calculateHierarchy } = useToast();
  const toast = getToast(toastId);
  const [hierarchy, setHierarchy] = useState(null);

  const [isEntering, setIsEntering] = useState(false);
  const [isExiting, setIsExiting] = useState(false);
  const [isOpen, setIsOpen] = useState(false);

  useEffect(() => {
    const index = calculateHierarchy(toastId);
    setHierarchy(index);

    if (!isOpen && toast?.visibility) {
      setIsEntering(true);
      setIsOpen(true);

      setTimeout(() => {
        setIsEntering(false);
      }, 500);
    } else if (isOpen && !toast?.visibility) {
      setIsExiting(true);

      setTimeout(() => {
        setIsOpen(false);
        setIsExiting(false);
      }, 300);
    }
  }, [toast]); // eslint-disable-line react-hooks/exhaustive-deps

  const directionDependentPositioning = {
    "top-right": {
      top: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
      right: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
    },
    "bottom-right": {
      right: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
      bottom: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
    },
    "top-left": {
      top: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
      left: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
    },
    "bottom-left": {
      left: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
      bottom: `${hierarchy !== null ? gapBetweenCardsInGroup * hierarchy : 0}rem`,
    },
  };

  return (
    <>
      {isOpen && (
        <div
          className={twMerge(
            "overflow-hidden w-max flex flex-col justify-between group-hover/toast:static transition-all duration-300 ease-linear",
            createStack ? "absolute" : "static",
            direction === "top-right" || direction === "bottom-right"
              ? "data-[entering=true]:animate-toastEntryRight data-[exiting=true]:animate-toastExit duration-200"
              : "data-[entering=true]:animate-toastEntryLeft data-[exiting=true]:animate-toastExit duration-200"
          )}
          style={
            createStack
              ? {
                  ...directionDependentPositioning[direction],
                  zIndex: hierarchy !== null ? hierarchy : -1,
                }
              : {}
          }
          data-entering={isEntering}
          data-exiting={isExiting}
          data-open={isOpen}
        >
          <ToastStyling toast={toast} />
        </div>
      )}
    </>
  );
}

// This is the only that you need to change in the code if you want custom styling
const ToastStyling = ({ toast }) => {
  const { removeToast } = useToast();

  return (
    <>
      {toast && (
        <div
          className={twMerge(
            "min-w-80 min-h-full rounded-md text-textPrimary flex justify-between font-semibold border-2 gap-6 py-2 px-4",
            toast.state === "success" &&
              "bg-success-secondary border-success text-success-foreground ",
            toast.state === "error" &&
              "bg-error-secondary border-error text-error-foreground",
            toast.state === "warning" &&
              "bg-alert-secondary border-alert text-alert-foreground",
            toast.state === "info" &&
              "bg-accent-secondary border-accent text-accent-foreground"
          )}
        >
          {toast.children}
          <button
            onClick={() => removeToast(toast.toastId)}
            className={twMerge(toast.closeType === "timeout" && "hidden")}
          >
            &#10005;
          </button>
        </div>
      )}
    </>
  );
};
```

```tsx|Implementation
const ToastDemo = () => {

  const { addToast } = useToast();
  const createToasts = () => {
    addToast({
      toastId: v4(),
      state: state,
      children: <h1>Hello</h1>,
      visibility: true,
      creationTime: Date.now(),
      closeType: closeType,
      duration: 5000,
    });
  };

  return (
    <div className="w-full flex flex-col items-center gap-8 text-foreground">
      <ToastGroup direction={direction} createStack={createStack} />
      <Button onClick={() => createToasts()} className="w-60">
        Create Toast
      </Button>
    </div>
  );
};

export const ToastImplementation = () => {
  return (
    <ToastProvider>
        <ToastDemo />
    </ToastProvider>
  );
};
```
```jsx|Implementation
const ToastDemo = () => {

  const { addToast } = useToast();
  const createToasts = () => {
    addToast({
      toastId: v4(),
      state: state,
      children: <h1>Hello</h1>,
      visibility: true,
      creationTime: Date.now(),
      closeType: closeType,
      duration: 5000,
    });
  };

  return (
    <div className="w-full flex flex-col items-center gap-8 text-foreground">
      <ToastGroup direction={direction} createStack={createStack} />
      <Button onClick={() => createToasts()} className="w-60">
        Create Toast
      </Button>
    </div>
  );
};

export const ToastImplementation = () => {
  return (
    <ToastProvider>
        <ToastDemo />
    </ToastProvider>
  );
};
```

```ts|tailwind.config
import type { Config } from "tailwindcss";
const config: Config = {
  theme: {
    extend: {
      animation: {
        toastEntryRight: "toastEntryRight 0.2s linear",
        toastEntryLeft: "toastEntryLeft 0.2s linear",
        toastExit: "toastExit 0.5s forwards",
      },
      keyframes: {

        toastEntryRight: {
          "0%": {
            transform: "translateX(100%)",
          },
          "100%": {
            transform: "translateX(0%)",
          },
        },
        toastEntryLeft: {
          "0%": {
            transform: "translateX(-100%)",
          },
          "100%": {
            transform: "translateX(0%)",
          },
        },
        toastExit: {
          "0%": {
            opacity: "1",
          },
          "100%": {
            opacity: "0",
          },
        }
      },
    },
  },
};
export default config;
```

```js|tailwind.config
const config = {
  theme: {
    extend: {
      animation: {
        toastEntryRight: "toastEntryRight 0.2s linear",
        toastEntryLeft: "toastEntryLeft 0.2s linear",
        toastExit: "toastExit 0.5s forwards",
      },
      keyframes: {

        toastEntryRight: {
          "0%": {
            transform: "translateX(100%)",
          },
          "100%": {
            transform: "translateX(0%)",
          },
        },
        toastEntryLeft: {
          "0%": {
            transform: "translateX(-100%)",
          },
          "100%": {
            transform: "translateX(0%)",
          },
        },
        toastExit: {
          "0%": {
            opacity: "1",
          },
          "100%": {
            opacity: "0",
          },
        }
      },
    },
  },
};
export default config;
```


</CodeBlock>


## ToastProps

| Name               | Type                                 | Description                                           |
|--------------------|--------------------------------------|-------------------------------------------------------|
| `toastId`          | `string`                             | Unique identifier for the toast.                      |
| `state`            | `"success" \| "error" \| "warning" \| "info"` | The state of the toast indicating its type.           |
| `children`         | `React.ReactNode`                    | The content to be displayed inside the toast.         |
| `visibility`       | `boolean`                            | Whether the toast is currently visible.               |
| `visibilityDuration`| `number` (optional)                  | Duration in milliseconds for how long the toast is visible. |
| `creationTime`     | `number`                             | The timestamp when the toast was created.             |
| `closeType`        | `"timeout" \| "manual"`              | The method by which the toast will be closed.         |
| `duration`         | `number`                             | The duration in milliseconds for how long the toast will be visible before closing. |

## ToastProviderProps

| Name               | Type                                   | Description                                           |
|--------------------|----------------------------------------|-------------------------------------------------------|
| `toasts`           | `ToastProps[]`                         | An array of `ToastProps` representing all toasts.     |
| `addToast`         | `(value: ToastProps) => void`          | Function to add a new toast.                          |
| `removeToast`      | `(id: string) => void`                 | Function to remove a toast by its ID.                 |
| `calculateHierarchy` | `(toastId: string) => number \| null` | Function to calculate the hierarchy of a toast.      |
| `getToast`         | `(id: string) => ToastProps \| null`   | Function to get a specific toast by its ID.           |

## ToastGroup Props

| Name            | Type                           | Description                                            |
|-----------------|--------------------------------|--------------------------------------------------------|
| `direction`     | `top-left` \| `top-right` \| `bottom-left` \| `bottom-right`           | The direction in which to display the toast group.     |
| `createStack`   | `boolean` (optional)           | Whether to create a stack of toasts.                   |

## Toast Props

| Name            | Type                           | Description                                            |
|-----------------|--------------------------------|--------------------------------------------------------|
| `toastId`       | `string`                       | Unique identifier for the toast.                       |
| `createStack`   | `boolean` (optional)           | Whether to create a stack of toasts.                   |
| `direction`     | `top-left` \| `top-right` \| `bottom-left` \| `bottom-right`              | The direction in which to display the toast.           |

## ToastStyling Props

| Name  | Type                 | Description                    |
|-------|----------------------|--------------------------------|
| `toast` | `ToastProps \| null` | The toast object to be styled.  |


</Implementation>
</Wrapper>
<PARTITION />
