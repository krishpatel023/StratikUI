import { Implementation, Preview, HeaderDefault, Display, TechnologyUsed, Wrapper } from "@/components/mdx/MDXServerImports"
import { CodeBlock, ResizableDisplay } from "@/components/mdx/MDXClientImports"
import { Demo } from "@/packages/hooks/useResizable/Demo.tsx"
import { genId } from "@/utils/helper";

export const generatedId = genId("component");

export const Data = {
    name: "useResizable",
    tags: [],
    description: "This hook is used to handle the resizing of an element. It can be used in multiple ways, such as pairing it with our Helper Function to make the entire implementation easy or else can be used as a standalone hook. It also has callback functions that can be used to show different messages to the user based on the current state of the hook.",
    version_included: "0.2.0",
    id: generatedId,
    display: true
}

<Wrapper>

# {Data.name}
### {Data.description}

<CodeBlock> 

```tsx|useResizable
"use client";

import { RefObject, useEffect, useState } from "react";

export interface ResizableOptions {
  minWidth?: string;
  minHeight?: string;
  maxWidth?: string;
  maxHeight?: string;
  onResizeStart?: () => void;
  onResize?: () => void;
  onResizeEnd?: () => void;
  expandBoundingElement?: boolean;
}

const useResizable = (
  containerRef: RefObject<HTMLDivElement>,
  resizableRef: RefObject<HTMLDivElement>,
  options: ResizableOptions = {}
) => {
  const {
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    onResizeStart,
    onResize,
    onResizeEnd,
    expandBoundingElement = true,
  } = options;

  // Will convert minWidth, minHeight, maxWidth, maxHeight to pixels
  const handleValue = (value: string) => {
    if (value.includes("px")) {
      return Number(value.replace("px", ""));
    } else if (value.includes("%")) {
      const percentage = Number(value.replace("%", ""));
      const containerRect = containerRef.current?.getBoundingClientRect();
      if (!containerRect) return 0;
      return (percentage * containerRect.width) / 100;
    }
    return 0;
  };

  const boundingDimensions = {
    minWidth: handleValue(minWidth || "0px"),
    minHeight: handleValue(minHeight || "0px"),
    maxWidth: handleValue(maxWidth || "100%"),
    maxHeight: handleValue(maxHeight || "100%"),
  };

  const [isResizing, setIsResizing] = useState(false);
  const [containerDimensions, setContainerDimensions] = useState({
    width: boundingDimensions.minWidth,
    height: boundingDimensions.minHeight,
  });
  const [activeHandle, setActiveHandle] = useState<
    "right" | "left" | "top" | "bottom" | null
  >(null);

  const stopSelection = () => {
    if (containerRef.current) {
      containerRef.current.style.userSelect = "none";
    }
  };

  const startSelection = () => {
    if (containerRef.current) {
      containerRef.current.style.userSelect = "auto";
    }
  };

  const handleMove = (e: TouchEvent | MouseEvent) => {
    e.preventDefault();

    if (!activeHandle || !isResizing || !resizableRef.current) return;

    const currentX = "touches" in e ? e.touches[0].clientX : e.clientX;
    const currentY = "touches" in e ? e.touches[0].clientY : e.clientY;

    const containerRect = containerRef.current?.getBoundingClientRect();
    const resizableRect = resizableRef.current?.getBoundingClientRect();

    if (!resizableRect || !containerRect) return;

    const startX = resizableRect.left;
    const startY = resizableRect.top;

    const initialWidth = resizableRect.width;
    const initialHeight = resizableRect.height;

    let newWidth = initialWidth;
    let newHeight = initialHeight;

    if (activeHandle === "right") {
      const deltaX = currentX - startX - initialWidth;
      newWidth = Math.max(initialWidth + deltaX, boundingDimensions.minWidth);
    }

    if (activeHandle === "left") {
      const deltaX = startX - currentX;
      newWidth = Math.max(initialWidth + deltaX, boundingDimensions.minWidth);
    }

    if (activeHandle === "bottom") {
      const deltaY = currentY - startY - initialHeight;
      newHeight = Math.max(
        initialHeight + deltaY,
        boundingDimensions.minHeight
      );
    }

    if (activeHandle === "top") {
      const deltaY = startY - currentY;
      newHeight = Math.max(
        initialHeight + deltaY,
        boundingDimensions.minHeight
      );
    }

    const widthFinal = Math.min(
      newWidth,
      containerRef.current?.clientWidth || Infinity
    );
    const heightFinal = Math.min(
      newHeight,
      containerRef.current?.clientHeight || Infinity
    );

    // This will prevent the bounding element from being expanded.
    if (!expandBoundingElement && containerRef.current) {
      if (
        widthFinal >= boundingDimensions.maxWidth ||
        heightFinal >= boundingDimensions.maxHeight
      )
        return;
    }

    resizableRef.current.style.width = `${widthFinal}px`;
    resizableRef.current.style.height = `${heightFinal}px`;

    setContainerDimensions({
      width: widthFinal,
      height: heightFinal,
    });

    if (onResize) onResize();
  };

  const handleResize = (
    e: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>,
    direction: "right" | "left" | "top" | "bottom"
  ) => {
    setActiveHandle(direction);
    setIsResizing(true);
    stopSelection();
    if (onResizeStart) onResizeStart();
  };

  const stopResize = () => {
    if (onResizeEnd) onResizeEnd();
    setActiveHandle(null);
    setIsResizing(false);
    startSelection();
  };

  useEffect(() => {
    containerRef.current?.addEventListener("touchmove", handleMove, {
      passive: false,
    });
    containerRef.current?.addEventListener("touchend", stopResize, {
      passive: false,
    });
    containerRef.current?.addEventListener("mousemove", handleMove);
    containerRef.current?.addEventListener("mouseup", stopResize);

    return () => {
      containerRef.current?.removeEventListener("touchmove", handleMove);
      containerRef.current?.removeEventListener("touchend", stopResize);
      containerRef.current?.removeEventListener("mousemove", handleMove);
      containerRef.current?.removeEventListener("mouseup", stopResize);
    };
  }, [handleMove, stopResize]);

  return {
    containerDimensions,
    isResizing,
    handleResize,
    stopResize,
    handleMove,
  };
};

export default useResizable;
```

```jsx|useResizable
"use client";

import { RefObject, useEffect, useState } from "react";

const useResizable = (
  containerRef,
  resizableRef,
  options = {}
) => {
  const {
    minWidth,
    minHeight,
    maxWidth,
    maxHeight,
    onResizeStart,
    onResize,
    onResizeEnd,
    expandBoundingElement = true,
  } = options;

  // Will convert minWidth, minHeight, maxWidth, maxHeight to pixels
  const handleValue = (value) => {
    if (value.includes("px")) {
      return Number(value.replace("px", ""));
    } else if (value.includes("%")) {
      const percentage = Number(value.replace("%", ""));
      const containerRect = containerRef.current?.getBoundingClientRect();
      if (!containerRect) return 0;
      return (percentage * containerRect.width) / 100;
    }
    return 0;
  };

  const boundingDimensions = {
    minWidth: handleValue(minWidth || "0px"),
    minHeight: handleValue(minHeight || "0px"),
    maxWidth: handleValue(maxWidth || "100%"),
    maxHeight: handleValue(maxHeight || "100%"),
  };

  const [isResizing, setIsResizing] = useState(false);
  const [containerDimensions, setContainerDimensions] = useState({
    width: boundingDimensions.minWidth,
    height: boundingDimensions.minHeight,
  });
  const [activeHandle, setActiveHandle] = useState(null);

  const stopSelection = () => {
    if (containerRef.current) {
      containerRef.current.style.userSelect = "none";
    }
  };

  const startSelection = () => {
    if (containerRef.current) {
      containerRef.current.style.userSelect = "auto";
    }
  };

  const handleMove = (e) => {
    e.preventDefault();

    if (!activeHandle || !isResizing || !resizableRef.current) return;

    const currentX = "touches" in e ? e.touches[0].clientX : e.clientX;
    const currentY = "touches" in e ? e.touches[0].clientY : e.clientY;

    const containerRect = containerRef.current?.getBoundingClientRect();
    const resizableRect = resizableRef.current?.getBoundingClientRect();

    if (!resizableRect || !containerRect) return;

    const startX = resizableRect.left;
    const startY = resizableRect.top;

    const initialWidth = resizableRect.width;
    const initialHeight = resizableRect.height;

    let newWidth = initialWidth;
    let newHeight = initialHeight;

    if (activeHandle === "right") {
      const deltaX = currentX - startX - initialWidth;
      newWidth = Math.max(initialWidth + deltaX, boundingDimensions.minWidth);
    }

    if (activeHandle === "left") {
      const deltaX = startX - currentX;
      newWidth = Math.max(initialWidth + deltaX, boundingDimensions.minWidth);
    }

    if (activeHandle === "bottom") {
      const deltaY = currentY - startY - initialHeight;
      newHeight = Math.max(
        initialHeight + deltaY,
        boundingDimensions.minHeight
      );
    }

    if (activeHandle === "top") {
      const deltaY = startY - currentY;
      newHeight = Math.max(
        initialHeight + deltaY,
        boundingDimensions.minHeight
      );
    }

    const widthFinal = Math.min(
      newWidth,
      containerRef.current?.clientWidth || Infinity
    );
    const heightFinal = Math.min(
      newHeight,
      containerRef.current?.clientHeight || Infinity
    );

    // This will prevent the bounding element from being expanded.
    if (!expandBoundingElement && containerRef.current) {
      if (
        widthFinal >= boundingDimensions.maxWidth ||
        heightFinal >= boundingDimensions.maxHeight
      )
        return;
    }

    resizableRef.current.style.width = `${widthFinal}px`;
    resizableRef.current.style.height = `${heightFinal}px`;

    setContainerDimensions({
      width: widthFinal,
      height: heightFinal,
    });

    if (onResize) onResize();
  };

  const handleResize = (
    e,
    direction
  ) => {
    setActiveHandle(direction);
    setIsResizing(true);
    stopSelection();
    if (onResizeStart) onResizeStart();
  };

  const stopResize = () => {
    if (onResizeEnd) onResizeEnd();
    setActiveHandle(null);
    setIsResizing(false);
    startSelection();
  };

  useEffect(() => {
    containerRef.current?.addEventListener("touchmove", handleMove, {
      passive: false,
    });
    containerRef.current?.addEventListener("touchend", stopResize, {
      passive: false,
    });
    containerRef.current?.addEventListener("mousemove", handleMove);
    containerRef.current?.addEventListener("mouseup", stopResize);

    return () => {
      containerRef.current?.removeEventListener("touchmove", handleMove);
      containerRef.current?.removeEventListener("touchend", stopResize);
      containerRef.current?.removeEventListener("mousemove", handleMove);
      containerRef.current?.removeEventListener("mouseup", stopResize);
    };
  }, [handleMove, stopResize]);

  return {
    containerDimensions,
    isResizing,
    handleResize,
    stopResize,
    handleMove,
  };
};

export default useResizable;
```

```tsx|Implementation
"use client";

import { useRef } from "react";
import { ResizableContainer, ResizeBoundingElement } from "./Resizable_Helper";
import useResizable from "@/packages/hooks/useResizable/useResizable";
import ArrowHeading from "@/components/ui/ArrowHeading";

export function ResizeExample1() {
  const containerRef = useRef<HTMLDivElement>(null);
  const resizableRef = useRef<HTMLDivElement>(null);

  const options = {
    minWidth: "100px",
    minHeight: "100px",
  };
  const { handleResize } = useResizable(containerRef, resizableRef, options);

  return (
    <div className="flex justify-center items-center flex-col gap-4 w-full">
      <ArrowHeading
        text="Bounding Element - can't resize outside this. However it can be expanded but the resize won't work outside this. This property can be adjusted in the options."
        className="text-center px-4"
      />
      <div className="w-full">
        <ResizeBoundingElement
          containerRef={containerRef}
          className="min-h-[400px] max-w-[90%] mx-auto bg-neutral-100 dark:bg-neutral-900 rounded-lg border-2 border-dashed dark:border-neutral-700"
        >
          <ResizableContainer
            minWidth={100}
            minHeight={100}
            direction={["right", "bottom", "top", "left"]}
            className="min-h-[600px] max-w-[95%] bg-neutral-300 dark:bg-neutral-900"
            handleResize={handleResize}
            resizableRef={resizableRef}
          >
            <div className="border dark:text-white w-full h-full text-center flex justify-center items-center">
              <h1>This is a resizable container</h1>
            </div>
          </ResizableContainer>
        </ResizeBoundingElement>
      </div>
    </div>
  );
}

export const ResizeBoundingElement = ({
  containerRef,
  className,
  children,
}: {
  containerRef: React.RefObject<HTMLDivElement>;
  children: React.ReactNode;
  className?: string;
}) => {
  return (
    <div ref={containerRef} className={twMerge("w-full", className)}>
      {children}
    </div>
  );
};

export const ResizableContainer = ({
  children,
  minWidth,
  minHeight,
  direction,
  handleResize,
  resizableRef,
  className,
}: {
  children: React.ReactNode;
  minWidth: number;
  minHeight: number;
  direction: ("right" | "bottom" | "top" | "left")[];
  className?: string;
  handleResize: (
    e:
      | React.MouseEvent<HTMLDivElement, MouseEvent>
      | React.TouchEvent<HTMLDivElement>,
    direction: "right" | "bottom" | "top" | "left"
  ) => void;
  resizableRef: React.RefObject<HTMLDivElement>;
}) => {
  return (
    <div className="w-max">
      <Handle
        direction="top"
        directionArr={direction}
        handleResize={handleResize}
      />
      <div className="h-full flex">
        <Handle
          direction="left"
          directionArr={direction}
          handleResize={handleResize}
        />
        <div
          ref={resizableRef}
          style={{
            minWidth: `${minWidth}px`,
            minHeight: `${minHeight}px`,
          }}
          className={className}
        >
          {children}
        </div>
        <Handle
          direction="right"
          directionArr={direction}
          handleResize={handleResize}
        />
      </div>
      <Handle
        direction="bottom"
        directionArr={direction}
        handleResize={handleResize}
      />
    </div>
  );
};

const Handle = ({
  direction,
  directionArr,
  handleResize,
}: {
  direction: "right" | "bottom" | "top" | "left";
  directionArr: ("right" | "bottom" | "top" | "left")[];
  handleResize: (
    e: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>,
    directions: "right" | "left" | "top" | "bottom"
  ) => void;
}) => {
  return (
    <>
      {directionArr.includes(direction) && (
        <>
          {(direction === "right" || direction === "left") && (
            <div
              className="w-4 flex justify-center items-center cursor-col-resize z-10"
              aria-label={`Resize ${direction}`}
              onMouseDown={(e) => handleResize(e, direction)}
              onTouchStart={(e) => handleResize(e, direction)}
            >
              <div className="min-h-8 bg-primary rounded-full min-w-[0.25rem]"></div>
            </div>
          )}
          {(direction === "top" || direction === "bottom") && (
            <div
              className="h-4 flex justify-center items-center cursor-row-resize z-10"
              aria-label={`Resize ${direction}`}
              onMouseDown={(e) => handleResize(e, direction)}
              onTouchStart={(e) => handleResize(e, direction)}
            >
              <div className="min-w-8 bg-primary rounded-full min-h-[0.25rem]"></div>
            </div>
          )}
        </>
      )}
    </>
  );
};
```
```jsx|Implementation
"use client";

import { useRef } from "react";
import useResizable from "@/packages/hooks/useResizable/useResizable";
import ArrowHeading from "@/components/ui/ArrowHeading";

export function ResizeExample1() {
  const containerRef = useRef(null);
  const resizableRef = useRef(null);

  const options = {
    minWidth: "100px",
    minHeight: "100px",
  };
  const { handleResize } = useResizable(containerRef, resizableRef, options);

  return (
    <div className="flex justify-center items-center flex-col gap-4 w-full">
      <ArrowHeading
        text="Bounding Element - can't resize outside this. However it can be expanded but the resize won't work outside this. This property can be adjusted in the options."
        className="text-center px-4"
      />
      <div className="w-full">
        <ResizeBoundingElement
          containerRef={containerRef}
          className="min-h-[400px] max-w-[90%] mx-auto bg-neutral-100 dark:bg-neutral-900 rounded-lg border-2 border-dashed dark:border-neutral-700"
        >
          <ResizableContainer
            minWidth={100}
            minHeight={100}
            direction={["right", "bottom", "top", "left"]}
            className="min-h-[600px] max-w-[95%] bg-neutral-300 dark:bg-neutral-900"
            handleResize={handleResize}
            resizableRef={resizableRef}
          >
            <div className="border dark:text-white w-full h-full text-center flex justify-center items-center">
              <h1>This is a resizable container</h1>
            </div>
          </ResizableContainer>
        </ResizeBoundingElement>
      </div>
    </div>
  );
}

export const ResizeBoundingElement = ({
  containerRef,
  className,
  children,
}) => {
  return (
    <div ref={containerRef} className={twMerge("w-full", className)}>
      {children}
    </div>
  );
};

export const ResizableContainer = ({
  children,
  minWidth,
  minHeight,
  direction,
  handleResize,
  resizableRef,
  className,
}) => {
  return (
    <div className="w-max">
      <Handle
        direction="top"
        directionArr={direction}
        handleResize={handleResize}
      />
      <div className="h-full flex">
        <Handle
          direction="left"
          directionArr={direction}
          handleResize={handleResize}
        />
        <div
          ref={resizableRef}
          style={{
            minWidth: `${minWidth}px`,
            minHeight: `${minHeight}px`,
          }}
          className={className}
        >
          {children}
        </div>
        <Handle
          direction="right"
          directionArr={direction}
          handleResize={handleResize}
        />
      </div>
      <Handle
        direction="bottom"
        directionArr={direction}
        handleResize={handleResize}
      />
    </div>
  );
};

const Handle = ({
  direction,
  directionArr,
  handleResize,
}) => {
  return (
    <>
      {directionArr.includes(direction) && (
        <>
          {(direction === "right" || direction === "left") && (
            <div
              className="w-4 flex justify-center items-center cursor-col-resize z-10"
              aria-label={`Resize ${direction}`}
              onMouseDown={(e) => handleResize(e, direction)}
              onTouchStart={(e) => handleResize(e, direction)}
            >
              <div className="min-h-8 bg-primary rounded-full min-w-[0.25rem]"></div>
            </div>
          )}
          {(direction === "top" || direction === "bottom") && (
            <div
              className="h-4 flex justify-center items-center cursor-row-resize z-10"
              aria-label={`Resize ${direction}`}
              onMouseDown={(e) => handleResize(e, direction)}
              onTouchStart={(e) => handleResize(e, direction)}
            >
              <div className="min-w-8 bg-primary rounded-full min-h-[0.25rem]"></div>
            </div>
          )}
        </>
      )}
    </>
  );
};
```
</CodeBlock>

## Props

| Props Name | Type | Description |
| --- | --- | --- |
| containerRef | RefObject\<HTMLDivElement> | A React ref object pointing to the container element that the resizable element is within. |
| resizableRef | RefObject\<HTMLDivElement> | A React ref object pointing to the element that is to be resized. |
| options | ResizableOptions | An object containing various optional properties to configure the behavior of the hook. |
| minWidth | string | The minimum width the resizable element can be, defined in pixels or percentage. |
| minHeight | string | The minimum height the resizable element can be, defined in pixels or percentage. |
| maxWidth | string | The maximum width the resizable element can be, defined in pixels or percentage. |
| maxHeight | string | The maximum height the resizable element can be, defined in pixels or percentage. |
| onResizeStart | () => void | A callback function that is called when the resize action starts. |
| onResize | () => void | A callback function that is called when the resizing is occurring. |
| onResizeEnd | () => void | A callback function that is called when the resize action ends. |
| expandBoundingElement | boolean | A boolean that determines whether the bounding element can be expanded beyond its initial size. |


## Properties

| Property Name | Type | Description |
| --- | --- | --- |
| containerDimensions | \{ width: number; height: number } | A state variable that holds the current dimensions (width and height) of the container element. |
| isResizing | boolean | A state variable indicating whether the resizing action is currently active (true) or not (false). |
| handleResize | (e: React.MouseEvent\<HTMLDivElement> \| React.TouchEvent\<HTMLDivElement>, direction: "right" \| "left" \| "top" \| "bottom") => void | A function that should be called when the user initiates a resize action. It takes the event object and the direction of resizing ("right," "left," "top," or "bottom") as arguments. |
| stopResize | () => void | A function that should be called when the resize action ends. It performs cleanup tasks and resets the state related to resizing. |
| handleMove | (e: TouchEvent \| MouseEvent) => void | A function that handles the movement during resizing. It calculates the new dimensions based on the active handle and user input. |

<Display>
    <Demo/>
</Display>
</Wrapper>