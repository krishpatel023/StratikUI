import { Implementation, Preview, HeaderDefault, Display, TechnologyUsed, Wrapper } from "@/components/mdx/MDXServerImports"
import { CodeBlock, ResizableDisplay } from "@/components/mdx/MDXClientImports"

import { genId } from "@/utils/helper";
import { Helper } from "@/packages/hooks/useDelay/Demo.tsx"

export const generatedId = genId("component");

export const Data = {
    name: "useDelay",
    tags: [],
    description: "The useDelay hook introduces a delay before executing a specified action, utilizing useTimeout and Promise for managing the delay.  This hook supports both synchronous and asynchronous functions, making it versatile for various use cases where deferred actions are needed, such as enhancing user experience or managing timed events.",
    version_included: "0.2.0",
    id: generatedId,
    display: true
}

<Wrapper>

# {Data.name}
### {Data.description}

<CodeBlock> 

```tsx|useDelay
"use client";

import { useCallback, useEffect, useRef, useState } from "react";

interface UseDelayOptions {
  immediate?: boolean;
}

interface UseDelayReturn {
  isDelaying: boolean;
  delay: (
    time: number,
    callback?: () => void,
    options?: UseDelayOptions
  ) => void;
  clearDelay: () => void;
}

const useDelay = (): UseDelayReturn => {
  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const [isDelaying, setIsDelaying] = useState<boolean>(false);

  useEffect(() => {
    return () => {
      clearDelay();
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  const delay = async (
    time: number,
    callback?: () => void,
    options: UseDelayOptions = {}
  ): Promise<void> => {
    const { immediate = false } = options;
    const executableFunc = callback || (() => {});

    if (immediate) {
      executableFunc();
    }

    return new Promise<void>((resolve) => {
      clearDelay();

      timerRef.current = setTimeout(() => {
        if (!immediate) {
          executableFunc();
        }
        setIsDelaying(false);
        resolve();
      }, time);

      setIsDelaying(true);
    });
  };

  const clearDelay = useCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
      setIsDelaying(false);
    }
  }, []);

  return { isDelaying, delay, clearDelay };
};

export default useDelay;
```

```jsx|useDelay
"use client";

import { useCallback, useEffect, useRef, useState } from "react";

const useDelay = () => {
  const timerRef = useRef(null);
  const [isDelaying, setIsDelaying] = useState(false);

  useEffect(() => {
    return () => {
      clearDelay();
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  const delay = async (
    time,
    callback,
    options = {}
  ) => {
    const { immediate = false } = options;
    const executableFunc = callback || (() => {});

    if (immediate) {
      executableFunc();
    }

    return new Promise((resolve) => {
      clearDelay();

      timerRef.current = setTimeout(() => {
        if (!immediate) {
          executableFunc();
        }
        setIsDelaying(false);
        resolve();
      }, time);

      setIsDelaying(true);
    });
  };

  const clearDelay = useCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = null;
      setIsDelaying(false);
    }
  }, []);

  return { isDelaying, delay, clearDelay };
};

export default useDelay;
```

```tsx|Implementation
"use client";

import useDelay from "./useDelay";
import { useRef, useState } from "react";
import useClickOutside from "@/hooks/ClickOutside";
import { twMerge } from "tailwind-merge";

function Modal({
  children,
  active,
  setActive,
  position = "center",
  className,
  blurBg = true,
}: {
  children: React.ReactNode;
  active: boolean;
  setActive: React.Dispatch<React.SetStateAction<boolean>>;
  position?: "center" | "top" | "bottom";
  className?: string;
  blurBg?: boolean;
}) {
  const ref = useRef(null);
  useClickOutside(ref, () => setActive(false));

  return (
    <>
      {active && (
        <ContainerGlassEffect
          className={twMerge(
            "w-full h-full fixed top-0 left-0 z-50 flex justify-center",
            !blurBg &&
              "bg-transparent dark:bg-transparent backdrop-blur-none supports-[backdrop-filter]:bg-transparent dark:supports-[backdrop-filter]:bg-transparent"
          )}
        >
          <div
            ref={ref}
            className={twMerge(
              "hidden absolute rounded-md px-6 py-6 border border-neutral-200 dark:border-neutral-700 bg-white dark:bg-neutral-950 text-black dark:text-white",
              active && "flex flex-col",
              position === "center" && "top-1/2 -translate-y-1/2",
              position === "top" && "top-6",
              position === "bottom" && "bottom-6",
              className
            )}
          >
            {children}
          </div>
        </ContainerGlassEffect>
      )}
    </>
  );
}

export function Demo() {
  const { isDelaying, delay, clearDelay } = useDelay();

  const [active, setActive] = useState<boolean>(false);

  // This way you can use it with async-await or .then
  const handleDelay = async () => {
    await delay(2000);
    setActive(true);
  };

  // This way you can use it without async-await or .then
  const handleDelayWithAction = () => {
    delay(2000, () => {
      setActive(true);
    });
  };

  const handleClearDelay = () => {
    clearDelay();
  };

  return (
    <div className="min-h-[35rem] flex flex-col justify-center items-center gap-6 text-center">
      <Modal active={active} setActive={setActive} className="max-w-[30rem]">
        <h1>This is the delayed action of your click.</h1>
        <span className="mt-4">
          <button
            onClick={() => setActive(false)}
            className="bg-s_foreground rounded-md text-s_textComplementary px-4 py-1 font-semibold"
          >
            Close
          </button>
        </span>
      </Modal>
      <h1 className="text-2xl text-black dark:text-white">
        {isDelaying ? "Delaying" : "Click to see the delayed action"}
      </h1>
      <div className="flex gap-4 flex-col @md:flex-row">
        <Button onClick={handleDelay}>Delay with Async</Button>
        <Button onClick={handleDelayWithAction}>Delay without Async</Button>
        <Button onClick={handleClearDelay}>Clear Delay</Button>
      </div>
    </div>
  );
}
```
```jsx|Implementation
"use client";

import useDelay from "./useDelay";
import { useRef, useState } from "react";
import useClickOutside from "@/hooks/ClickOutside";
import { twMerge } from "tailwind-merge";

function Modal({
  children,
  active,
  setActive,
  position = "center",
  className,
  blurBg = true,
}) {
  const ref = useRef(null);
  useClickOutside(ref, () => setActive(false));

  return (
    <>
      {active && (
        <ContainerGlassEffect
          className={twMerge(
            "w-full h-full fixed top-0 left-0 z-50 flex justify-center",
            !blurBg &&
              "bg-transparent dark:bg-transparent backdrop-blur-none supports-[backdrop-filter]:bg-transparent dark:supports-[backdrop-filter]:bg-transparent"
          )}
        >
          <div
            ref={ref}
            className={twMerge(
              "hidden absolute rounded-md px-6 py-6 border border-neutral-200 dark:border-neutral-700 bg-white dark:bg-neutral-950 text-black dark:text-white",
              active && "flex flex-col",
              position === "center" && "top-1/2 -translate-y-1/2",
              position === "top" && "top-6",
              position === "bottom" && "bottom-6",
              className
            )}
          >
            {children}
          </div>
        </ContainerGlassEffect>
      )}
    </>
  );
}

export function Demo() {
  const { isDelaying, delay, clearDelay } = useDelay();

  const [active, setActive] = useState(false);

  // This way you can use it with async-await or .then
  const handleDelay = async () => {
    await delay(2000);
    setActive(true);
  };

  // This way you can use it without async-await or .then
  const handleDelayWithAction = () => {
    delay(2000, () => {
      setActive(true);
    });
  };

  const handleClearDelay = () => {
    clearDelay();
  };

  return (
    <div className="min-h-[35rem] flex flex-col justify-center items-center gap-6 text-center">
      <Modal active={active} setActive={setActive} className="max-w-[30rem]">
        <h1>This is the delayed action of your click.</h1>
        <span className="mt-4">
          <button
            onClick={() => setActive(false)}
            className="bg-s_foreground rounded-md text-s_textComplementary px-4 py-1 font-semibold"
          >
            Close
          </button>
        </span>
      </Modal>
      <h1 className="text-2xl text-black dark:text-white">
        {isDelaying ? "Delaying" : "Click to see the delayed action"}
      </h1>
      <div className="flex gap-4 flex-col @md:flex-row">
        <Button onClick={handleDelay}>Delay with Async</Button>
        <Button onClick={handleDelayWithAction}>Delay without Async</Button>
        <Button onClick={handleClearDelay}>Clear Delay</Button>
      </div>
    </div>
  );
}
```
</CodeBlock>

## Properties

| Property   | Type                                                                                | Description |
| ---------- | ----------------------------------------------------------------------------------- | --- |
| isDelaying | boolean                                                                             | It will tell you if there is delay in progress or not |
| delay      | (time: number, callback?: () => void, options?: UseDelayOptions) => Promise\<void\> | Delay function that returns a promise. If a callback is passed it will be executed and there will be no need of awaiting it. If not then it will delay the process and execute whatever is next, but will need async-await for it. |
| clearDelay | () => void                                                                          | Clear delay will stop the delay process. |

<Display>
    <Helper/>
</Display>
</Wrapper>